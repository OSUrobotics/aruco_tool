"""
Specifically testing package's ability to analyze aruco codes poses, given corners
"""

from aruco_tool import CornerFinder, PoseDetector, ArucoLoc
import pandas as pd
import numpy as np


def test_corner_translation_to_pose():
    """
    Check that the aruco loc object generated by a pose detector has the same attributes as the original aruco corner object 
    """
    t1 = CornerFinder("stream_appear")
    ids_found = t1.corner_analysis()

    zero_index = 1 # grabbing the id 0 aruco code, used to be consistently index 1, but adding for loop just in case
    for i, a in enumerate(ids_found):
        if a.id == 0:
            zero_index = i
            break
    
    ac = ids_found[zero_index]

    mtx = np.array(((617.0026849655, -0.153855356, 315.5900337131),  # fx, s,cx
                            (0, 614.4461785395, 243.0005874753),  # 0,fy,cy
                            (0, 0, 1)))
    dist = np.array((0.1611730644, -0.3392379107, 0.0010744837, 0.000905697))

    pdetect = PoseDetector(ac, mtx, dist, 0.03, 1)

    test_data = pdetect.find_marker_locations()

    filt_data = test_data._moving_average()

    assert ac.id == test_data.id
    assert ac.folder_loc == test_data.folder_loc
    assert ac.data_len == test_data.data_len


def test_arucoloc_creation():
    """
    Test that the ArucoLoc is made correctly
    """
    test_poses = np.array([[1, 1, 1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2, 2, 2, 2], [3, 3, 3, 3, 3, 3, 3, 3]])

    test_aruco_loc = ArucoLoc(1, test_poses, file_folder="test")

    assert test_aruco_loc.id == 1
    assert test_aruco_loc.data_len == 3
    assert test_aruco_loc.file_folder == "test"


def test_moving_average_preceeding_nans_poses():
    """
    Tests that the moving average function correctly handles the moving average when there are trailing nans. The trailing nans should still exist, contrary to what pandas rolling average would do on its own
    """
    t1 = CornerFinder("stream_appear")
    ids_found = t1.corner_analysis()

    zero_index = 1 # grabbing the id 0 aruco code, used to be consistently index 1, but adding for loop just in case
    for i, a in enumerate(ids_found):
        if a.id == 0:
            zero_index = i
            break
    
    ac = ids_found[zero_index]

    mtx = np.array(((617.0026849655, -0.153855356, 315.5900337131),  # fx, s,cx
                            (0, 614.4461785395, 243.0005874753),  # 0,fy,cy
                            (0, 0, 1)))
    dist = np.array((0.1611730644, -0.3392379107, 0.0010744837, 0.000905697))

    pdetect = PoseDetector(ac, mtx, dist, 0.03, 1)

    test_data = pdetect.find_marker_locations()

    filt_data = test_data._moving_average()

    assert np.all(np.isnan(filt_data[0]) & np.all(np.isnan(filt_data[1])))


def test_moving_average_trailing_nans_poses():
    """
    Tests that the moving average function correctly handles the moving average when there are trailing nans. The trailing nans should still exist, contrary to what pandas rolling average would do on its own
    """
    t1 = CornerFinder("stream_disappear")
    ids_found = t1.corner_analysis()

    zero_index = 1 # grabbing the id 0 aruco code, used to be consistently index 1, but adding for loop just in case
    for i, a in enumerate(ids_found):
        if a.id == 0:
            zero_index = i
            break
    
    ac = ids_found[zero_index]

    mtx = np.array(((617.0026849655, -0.153855356, 315.5900337131),  # fx, s,cx
                            (0, 614.4461785395, 243.0005874753),  # 0,fy,cy
                            (0, 0, 1)))
    dist = np.array((0.1611730644, -0.3392379107, 0.0010744837, 0.000905697))

    pdetect = PoseDetector(ac, mtx, dist, 0.03, 1)

    test_data = pdetect.find_marker_locations()

    filt_data = test_data._moving_average()

    assert np.all(np.isnan(filt_data[4]) & np.all(np.isnan(filt_data[5])))
